oid mostrar_proceso_modificador(const char *archivo) {
    char cmd[512];
    // Llamamos solo a ausearch y capturamos TODO el bloque SYSCALL+PATH
    snprintf(cmd, sizeof(cmd),
             "/usr/sbin/ausearch -f \"%s\" -ts recent 2>/dev/null",
             archivo);

    FILE *fp = popen(cmd, "r");
    if (!fp) {
        fprintf(stderr, "[DEBUG] popen fall√≥ al ejecutar: %s\n", cmd);
        return;
    }

    char line[1024];
    char comm[128] = "(no registrado)",
         exe[256]  = "(no registrado)",
         tty[64]   = "(no registrado)",
         uid[32]   = "(no registrado)";
    int in_syscall = 0, encontrado = 0;

    while (fgets(line, sizeof(line), fp)) {
        // Detectamos el inicio del bloque SYSCALL
        if (strstr(line, "type=SYSCALL")) {
            in_syscall = 1;
            encontrado = 0;  // reiniciamos por si hay varios bloques
        }
        if (!in_syscall) continue;

        // Si es PATH, salimos del bloque tras registrarlo
        if (strstr(line, "type=PATH")) {
            break;
        }

        // Extraemos campos
        char *p;
        if ((p = strstr(line, "comm=\"")) && sscanf(p + 6, "%127[^\"]", comm) == 1) {
            encontrado = 1;
        }
        if ((p = strstr(line, "exe=\"")) && sscanf(p + 5, "%255[^\"]", exe) == 1) {
            encontrado = 1;
        }
        if ((p = strstr(line, "tty=")) && sscanf(p + 4, "%63s", tty) == 1) {
            encontrado = 1;
        }
        if ((p = strstr(line, "uid=")) && sscanf(p + 4, "%31s", uid) == 1) {
            encontrado = 1;
        }
    }

    pclose(fp);

    if (encontrado) {
        printf("   üîé Ultimo proceso que accedio a %s:\n", archivo);
        printf("      üß† Comando: %s\n", comm);
        printf("      üìÅ Ejecutable: %s\n", exe);
        printf("      üë§ UID: %s\n", uid);
        printf("      üñ• TTY: %s\n", tty);
        // Heur√≠stica
        if (strcmp(tty, "(no registrado)") != 0 && strcmp(tty, "?") != 0) {
            printf("      üßç Probablemente un cambio manual (usuario en terminal)\n");
        } else if (strstr(exe, "bash") || strstr(exe, "sh") || strstr(exe, "python")) {
            printf("      ü§ñ Probablemente un script autom√°tico\n");
        } else {
            printf("      ‚ùì Origen del cambio: desconocido\n");
        }
    } else {
        printf("   ‚ö†Ô∏è No se encontr√≥ registro de auditor√≠a para %s\n", archivo);
    }
}
// New function to log an alert
void log_alert(const char* alert_file, 
                const char* alert_message,
                const char* file_itself) {
    // Use a more robust method to prevent duplicate logging


    printf("Entered with message: %s\n", alert_message);

    const char *syscall = determinar_syscall_por_alerta(alert_message);
    if (syscall) {
        mostrar_proceso_modificador(file_itself);
    }



    FILE* log = fopen(alert_file, "a");
    if (log) {
        time_t now = time(NULL);
        char timestamp[64];
        strftime(timestamp, sizeof(timestamp), "[%a %b %d %H:%M:%S %Y] ", localtime(&now));
        fprintf(log, "%s%s\n", timestamp, alert_message);
        fclose(log);
    } 
}