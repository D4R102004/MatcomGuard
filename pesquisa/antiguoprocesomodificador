void mostrar_proceso_modificador(const char *archivo) {
    char cmd[512];
    // Llamamos solo a ausearch y capturamos TODO el bloque SYSCALL+PATH
    snprintf(cmd, sizeof(cmd),
             "/usr/sbin/ausearch -f \"%s\" -ts recent 2>/dev/null",
             archivo);

    FILE *fp = popen(cmd, "r");
    if (!fp) {
        fprintf(stderr, "[DEBUG] popen fall√≥ al ejecutar: %s\n", cmd);
        return;
    }

    char line[1024];
    char comm[128] = "(no registrado)",
         exe[256]  = "(no registrado)",
         tty[64]   = "(no registrado)",
         uid[32]   = "(no registrado)";
    int in_syscall = 0, encontrado = 0;

    while (fgets(line, sizeof(line), fp)) {
        // Detectamos el inicio del bloque SYSCALL
        if (strstr(line, "type=SYSCALL")) {
            in_syscall = 1;
            encontrado = 0;  // reiniciamos por si hay varios bloques
        }
        if (!in_syscall) continue;

        // Si es PATH, salimos del bloque tras registrarlo
        if (strstr(line, "type=PATH")) {
            break;
        }

        // Extraemos campos
        char *p;
        if ((p = strstr(line, "comm=\"")) && sscanf(p + 6, "%127[^\"]", comm) == 1) {
            encontrado = 1;
        }
        if ((p = strstr(line, "exe=\"")) && sscanf(p + 5, "%255[^\"]", exe) == 1) {
            encontrado = 1;
        }
        if ((p = strstr(line, "tty=")) && sscanf(p + 4, "%63s", tty) == 1) {
            encontrado = 1;
        }
        if ((p = strstr(line, "uid=")) && sscanf(p + 4, "%31s", uid) == 1) {
            encontrado = 1;
        }
    }

    pclose(fp);

    if (encontrado) {
        printf("   üîé Proceso responsable de %s:\n", archivo);
        printf("      üß† Comando: %s\n", comm);
        printf("      üìÅ Ejecutable: %s\n", exe);
        printf("      üë§ UID: %s\n", uid);
        printf("      üñ• TTY: %s\n", tty);
        // Heur√≠stica
        if (strcmp(tty, "(no registrado)") != 0 && strcmp(tty, "?") != 0) {
            printf("      üßç Probablemente un cambio manual (usuario en terminal)\n");
        } else if (strstr(exe, "bash") || strstr(exe, "sh") || strstr(exe, "python")) {
            printf("      ü§ñ Probablemente un script autom√°tico\n");
        } else {
            printf("      ‚ùì Origen del cambio: desconocido\n");
        }
    } else {
        printf("   ‚ö†Ô∏è No se encontr√≥ registro de auditor√≠a para %s\n", archivo);
    }
}


void mostrar_proceso_modificador(const char *archivo,
                                 const char *syscall) {
    char cmd[512];
    char buffer[1024];


    printf("üîç Buscando proceso que ejecut√≥ syscall '%s' sobre el archivo '%s'\n", syscall, archivo);

    // We get the most recent syscall-specific audit log entry related to this file
    snprintf(cmd, sizeof(cmd),
             "/usr/sbin/ausearch -f \"%s\" -sc %s -k usb_monitoring | tac | awk '/^----/ {exit} {print}'",
             archivo, syscall);



    FILE *fp = popen(cmd, "r");
    if (!fp) {
        fprintf(stderr, "[DEBUG] popen fall√≥ al ejecutar: %s\n", cmd);
        return;
    }

    char line[1024];
    char comm[128] = "(no registrado)",
         exe[256]  = "(no registrado)",
         tty[64]   = "(no registrado)",
         uid[32]   = "(no registrado)";
    int in_syscall = 0, encontrado = 0;

    while (fgets(line, sizeof(line), fp)) {
        // Detectamos el inicio del bloque SYSCALL
        if (strstr(line, "type=SYSCALL")) {
            in_syscall = 1;
            encontrado = 0;  // reiniciamos por si hay varios bloques
        }
        if (!in_syscall) continue;

        // Si es PATH, salimos del bloque tras registrarlo
        if (strstr(line, "type=PATH")) {
            break;
        }

        // Extraemos campos
        char *p;
        if ((p = strstr(line, "comm=\"")) && sscanf(p + 6, "%127[^\"]", comm) == 1) {
            encontrado = 1;
        }
        if ((p = strstr(line, "exe=\"")) && sscanf(p + 5, "%255[^\"]", exe) == 1) {
            encontrado = 1;
        }
        if ((p = strstr(line, "tty=")) && sscanf(p + 4, "%63s", tty) == 1) {
            encontrado = 1;
        }
        if ((p = strstr(line, "uid=")) && sscanf(p + 4, "%31s", uid) == 1) {
            encontrado = 1;
        }
    }

    pclose(fp);

    if (encontrado) {
        printf("   üîé Proceso responsable de %s:\n", archivo);
        printf("      üß† Comando: %s\n", comm);
        printf("      üìÅ Ejecutable: %s\n", exe);
        printf("      üë§ UID: %s\n", uid);
        printf("      üñ• TTY: %s\n", tty);
        // Heur√≠stica
        if (strcmp(tty, "(no registrado)") != 0 && strcmp(tty, "?") != 0) {
            printf("      üßç Probablemente un cambio manual (usuario en terminal)\n");
        } else if (strstr(exe, "bash") || strstr(exe, "sh") || strstr(exe, "python")) {
            printf("      ü§ñ Probablemente un script autom√°tico\n");
        } else {
            printf("      ‚ùì Origen del cambio: desconocido\n");
        }
    } else {
        printf("   ‚ö†Ô∏è No se encontr√≥ registro de auditor√≠a para %s\n", archivo);
    }
}